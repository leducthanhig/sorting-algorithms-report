\subsection{Merge Sort}

\subsubsection{Ý tưởng}

Thuật toán sắp xếp trộn sử dụng phương pháp chia để trị (divide-and-conquer). Đầu tiên, chia mảng $a[1..n]$ thành 2 mảng con có kích thước $n/2$ là $a[1..mid]$ và $a[mid + 1..n]$, sắp xếp và trộn hai mảng này lại, ta thu được mảng $n/2$ phần tử đã được sắp xếp. Để sắp xếp mảng $n/2$ phần tử ta lại tiếp tục chia thành hai mảng có $n/4$ phần tử, cứ như vậy gọi đệ quy cho đến khi mảng chỉ có 1 phần tử thì xem như là đã được sắp xếp.

\subsubsection{Mã giả}

\begin{algorithm}[H]
\caption{Merge Sort}
\label{merge-sort}

\SetKwFunction{mergeTwoArrays}{mergeTwoArrays}
\SetKwProg{Fn}{Function}{:}{}
\Fn{\mergeTwoArrays {arr\KwSty{[ ]}, arr1\KwSty{[ ]}, n1, arr2\KwSty{[ ]}, n2}}{
    $i \gets 0, \hspace{0.2cm} j \gets 0$ \\
    \While{$i < n1$ \KwSty{and} $j < n2$}{
        \If{$arr1[i] < arr2[j]$}{ 
            Thêm $arr1[i]$ vào $arr$ \\
            $++i$ \\
        }
        \Else{
            Thêm $arr2[j]$ vào $arr$ \\
            $++j$ \\
        }
    }
    \While{$i < n1$}{
        Thêm $arr1[i]$ vào $arr$ \\
        $++i$ \\
    }
    \While{$j < n2$}{
        Thêm $arr2[j]$ vào $arr$ \\
        $++j$ \\
    }
}
\textbf{end function}

\SetKwFunction{MergeSort}{MergeSort}
\SetKwProg{Fn}{Function}{:}{}
\Fn{\MergeSort {arr\KwSty{[ ]}, left, right}}{
    \If{$left < right$}{ 
        Tạo mảng $a1 = arr[left..mid]$ có $n1$ phần tử \\
        Tạo mảng $a2 = arr[mid+1..right]$ có $n2$ phần tử \\
        \MergeSort{arr, left, mid} \\
        \MergeSort{arr, mid + 1, right} \\
        \mergeTwoArrays{arr, a1, n1, a2, n2}
    }
}
\textbf{end function}
\end{algorithm}

\subsubsection{Ví dụ}

\subsubsection{Độ phức tạp thuật toán}

\begin{itemize}
    \item Độ phức tạp thời gian \\
    Mảng ban đầu có $n$ phần tử cần sắp xếp sẽ được chia đôi nhiều lần cho đến khi nó chỉ còn 1 phần tử, như vậy sẽ có $log_2{n}$ mức đệ quy. Ở mỗi mức đệ quy, ta duyệt qua các phần tử ở tất cả mảng con để thực hiện trộn nên độ phức tạp là $O(n)$. Như vậy độ phức tạp của thuật toán Merge Sort là $O(nlogn)$. Có thể thấy thuật toán không phụ thuộc vào phân bố ban đầu của dữ liệu, do đó ta có:
    \begin{itemize}[label=$\circ$]
        \item Trường hợp tốt nhất: $O(nlogn)$
        \item Trường hợp xấu nhất: $O(nlogn)$
        \item Trường hợp trung bình: $O(nlogn)$ 
    \end{itemize}
    
    \item Độ phức tạp không gian: $O(n)$, vì thuật toán cần tạo thêm không gian để chứa những phần tử từ 2 mảng con rồi mới trộn vào mảng ban đầu.
\end{itemize}