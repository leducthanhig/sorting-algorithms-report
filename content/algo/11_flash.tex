\subsection{Flash Sort}

\subsubsection{Ý tưởng}

Dựa trên phân phối, khai thác sự phân phối tự nhiên của dữ liệu đầu vào để đạt được độ phức tạp thời gian tuyến tính $O(n)$ cho dữ liệu phân phối đồng đều. Bao gồm 3 phần chính: phân loại, hoán vị và chèn trực tiếp.

\begin{itemize}
	\item Phân loại
		\begin{itemize}[label=$\circ$]
			\item Chia các phần tử thành các lớp dựa trên giá trị của chúng. 
			\item Sử dụng mối quan hệ tuyến tính giữa giá trị phần tử và vị trí của chúng. 
			\item Công thức: $class(x) = \dfrac{(m-1)(x-min)}{max-min}$
		\end{itemize}
	\item Hoán vị
		\begin{itemize}[label=$\circ$]
			\item Di chuyển các phần tử đến vị trí gần đúng của chúng. 
			\item Tạo ra sự sắp xếp sơ bộ dựa trên phân phối lớp. 
		\end{itemize}
	\item Chèn trực tiếp: Sử dụng sắp xếp chèn để sắp xếp lại lần cuối cùng.
		\begin{itemize}[label=$\circ$]
			\item Hiệu quả vì các phần tử đã gần như được sắp xếp.  
			\item Hoạt động trên các phạm vi nhỏ trong các lớp.  
		\end{itemize}
\end{itemize}

\subsubsection{Mã giả}

\begin{algorithm}[H]
	\caption{Flash Sort}
	\label{flash-sort}
	\SetKwFunction{FlashSort}{FlashSort}
	\SetKwProg{Fn}{Function}{:}{}
	\Fn{\FlashSort {arr\KwSty{[ ]}, n}}{
		// Tìm giá trị nhỏ nhất và lớn nhất trong mảng $arr$ \\
		$a\_imin = arr[0], \hspace{0.2cm} imax = 0$ \\
		\For{$i = 0$ \KwTo $n-1$}{
			\If{$arr[i] < a\_imin$}{
				$a\_imin = arr[i]$
			}
			\If{$arr[i] > arr[imax]$}{
				$imax = i$
			}
		}
		// Tính số lượng lớp cần phân loại \\
		$m = max(0.45 * n, 1)$ \\
		Khởi tạo mảng $L$ với kích thước $m$ \\
		$c1 = (m - 1.0) / (arr[imax] - a\_imin)$ \\
			\For{$i = 0$ \KwTo $n-1$}{
			$L[c1 * (arr[i] - a\_imin)]++$
		}
		\For{$i = 1$ \KwTo $m-1$}{
			$L[i] += L[i - 1]$
		}
		swap($arr[imax]$, $arr[0]$) \\
		// Hoán vị \\
		$nmove = 0, \hspace{0.2cm} j = 0, \hspace{0.2cm} k = m - 1$ \\
	}
\end{algorithm}

%----------------------------------------------------------------------

\begingroup
\renewcommand{\thealgocf}{} % Loại bỏ số thứ tự
\setlength{\algotitleheightrule}{0pt} % Loại bỏ dòng kẻ trên tiêu đề
\setlength{\interspacetitleruled}{0pt} % Không khoảng cách giữa tiêu đề và đường kẻ
\setlength{\interspacealgoruled}{0pt} % Không khoảng cách giữa đường kẻ và nội dung

\begin{algorithm}[H]
	\setcounter{AlgoLine}{24} % Tiếp tục số dòng từ phần trước
	\SetInd{1em}{1em} % Đặt khoảng thụt lề tương tự phần 1
	\SetKwProg{Fn}{}{}{} % Không hiển thị "Function" ở phần 2
	\Fn{}{% Duy trì khối thụt lề và vline
		\While{$nmove < n - 1$}{
			\While{$j > L[k] - 1$}{
				$j++$ \\
				$k = c1 * (arr[j] - a\_imin)$
			}
			$flash = arr[j]$ \\
			\While{$j != L[k]$}{
				$k = c1 * (flash - a\_imin)$ \\
				swap($flash$, $arr[L[k] - 1]$) \\
				$L[k]--, \hspace{0.2cm} nmove++$
			}
		}
		InsertionSort(a, n) \tcp{Chèn trực tiếp trên phạm vi từng lớp}
	}
	\textbf{end function}
\end{algorithm}

\subsubsection{Ví dụ}

\begin{tikzpicture}[node distance=0cm, font=\sffamily, every node/.style={minimum width=1cm, minimum height=1cm, outer sep=0pt, anchor = west}, line join=miter, line cap=rect]
	
	% Trạng thái ban đầu
	\node[font=\rmfamily] at (0, 0) {Giả sử ta có mảng ban đầu với $n=7$ như sau:};
	\node[draw, fill=white] at (9, 0) {8};
	\node[draw, fill=white] at (10, 0) {3};
	\node[draw, fill=white] at (11, 0) {1};
	\node[draw, fill=white] at (12, 0) {7};
	\node[draw, fill=white] at (13, 0) {0};
	\node[draw, fill=white] at (14, 0) {10};
	\node[draw, fill=white] at (15, 0) {2};
	
\end{tikzpicture}

\textbf{Bước 1:} Tìm giá trị nhỏ nhất và lớn nhất: $min=0$, $max=10$ (ở vị trí $imax=5$).

\textbf{Bước 2:} Tính được số lớp $m = max(0,45*n,1) = 3$.

Từ đó dựa vào công thức phân lớp ở phần ý tưởng, ta xác định được:

\hspace{0.5cm} $\bullet$ Lớp 0 gồm các phần tử: 3, 1, 0, 2.

\hspace{0.5cm} $\bullet$ Lớp 1 gồm các phần tử: 8, 7.

\hspace{0.5cm} $\bullet$ Lớp 2 gồm phần tử: 10.

\begin{tikzpicture}[node distance=0cm, font=\sffamily, every node/.style={minimum width=1cm, minimum height=1cm, outer sep=0pt, anchor = west}, line join=miter, line cap=rect]
	
	% Trạng thái ban đầu
	\node[font=\rmfamily] at (0, -0.5) {{\bfseries Bước 3:} Hoán vị $a[imax]$ với $a[0]$ được:};
	\node[draw, fill=yellow] at (9, -0.4) {10};
	\node[draw, fill=white] at (10, -0.4) {3};
	\node[draw, fill=white] at (11, -0.4) {1};
	\node[draw, fill=white] at (12, -0.4) {7};
	\node[draw, fill=white] at (13, -0.4) {0};
	\node[draw, fill=yellow] at (14, -0.4) {8};
	\node[draw, fill=white] at (15, -0.4) {2};
	
	\node[font=\rmfamily] at (0, -1.5) {{\bfseries Bước 4:} Phân hoạch các phần tử vào các phân vùng:};
	
\end{tikzpicture}



\subsubsection{Độ phức tạp thuật toán}

\begin{itemize}
	\item Độ phức tạp thời gian
	\begin{itemize}[label=$\circ$]
		\item Trường hợp tốt nhất: $O(n)$. Khi mảng đầu vào có các phần tử 
		phân bố đều, và số lượng lớp được chọn hợp lý. Trong trường hợp 
		này, các phần tử được phân phối đều giữa các lớp, giảm tối đa số 
		lần hoán đổi. Việc sắp xếp trong mỗi lớp bằng Insertion Sort được 
		thực hiện nhanh chóng do số phần tử trong mỗi lớp nhỏ. Tất cả các 
		bước chính (phân loại, hoán vị và chèn trực tiếp) đều có độ phức 
		tạp là $O(n)$.
		\item Trường hợp xấu nhất: $O(n^2)$. Khi các phần tử trong mảng phân 
		phối không đều hoặc số lượng lớp được chọn không hợp lý. Khi đó, một 
		số lớp có thể chứa nhiều phần tử, dẫn đến việc sắp xếp trong lớp trở 
		thành $O(k^2)$, với $k$ là số phần tử trong lớp lớn nhất. Nếu số lượng 
		lớp quá nhỏ, thuật toán mất lợi thế phân chia và gần như phải sắp xếp 
		toàn bộ mảng trong một lớp lớn.
		\item Trường hợp trung bình: $O(n)$. Trong trường hợp này, các phần 
		tử được phân phối đủ đều giữa các lớp và việc sắp xếp trong lớp 
		diễn ra hiệu quả. Thuật toán duy trì độ phức tạp tuyến tính trong 
		cả ba bước (phân loại, hoán vị và chèn trực tiếp).
	\end{itemize}
	
	\item Độ phức tạp không gian: $O(n)$. Flash Sort yêu cầu không gian 
	phụ để lưu mảng lớp, với kích thước bằng số lượng lớp $(m)$. Trong 
	trường hợp điển hình, $m \approx n/2$, dẫn đến độ phức tạp không gian 
	là $O(n)$.
\end{itemize}