\subsection{Selection Sort}

Là một thuật toán sắp xếp đơn giản dựa trên việc tìm kiếm 
và đặt phần tử nhỏ nhất (hoặc lớn nhất) vào đúng vị trí 
của nó trong danh sách. Thuật toán này được gọi là "Selection" 
vì mỗi lần lặp, nó chọn phần tử phù hợp để đặt vào vị trí 
chính xác. Đây là một thuật toán không ổn định (unstable) 
vì nếu các phần tử có giá trị bằng nhau, thứ tự ban đầu có thể 
bị thay đổi do hoán vị.

\subsubsection{Ý tưởng}

\begin{enumerate}
    \item Chia danh sách thành hai phần:
    \begin{itemize}[label=$\circ$]
        \item Phần đã sắp xếp (ban đầu trống).
        \item Phần chưa sắp xếp (ban đầu chứa toàn bộ danh sách).
    \end{itemize}
    \item Lặp qua danh sách:
    \begin{itemize}[label=$\circ$]
        \item Tìm phần tử nhỏ nhất trong phần chưa sắp xếp.
        \item Hoán đổi phần tử nhỏ nhất này với phần tử đầu tiên 
        của phần chưa sắp xếp.
    \end{itemize}
    \item Sau mỗi lần hoán đổi, mở rộng phần đã sắp xếp thêm 
    một phần tử.
    \item Tiếp tục cho đến khi toàn bộ danh sách được sắp xếp.
\end{enumerate}

\subsubsection{Mã giả}

\begin{algorithm}[H]
\caption{Selection Sort}
\SetKwFunction{SelectionSort}{SelectionSort}
\SetKwProg{Fn}{Function}{:}{}
\Fn{\SelectionSort{a\KwSty{[]}, n}}{
    \For{$i \gets 0$ \KwTo $n-2$}{
        // Bước 1: Giả định phần tử nhỏ nhất là a[i] \\
        $minIndex \gets i$ \\
        // Bước 2: Tìm phần tử nhỏ nhất trong phần chưa sắp xếp \\
        \For{$j \gets i+1$ \KwTo $n-1$}{
            \If{$a[j] < a[minIndex]$}{
                $minIndex \gets j$ \\
            }
        }
        // Bước 3: Hoán đổi phần tử nhỏ nhất với a[i] \\
        \If{$minIndex \neq i$}{
            swap($a[i]$, $a[minIndex]$) \\
        }
    }
}
\textbf{end function}
\end{algorithm}

\subsubsection{Ví dụ}

\subsubsection{Độ phức tạp thuật toán}

\begin{itemize}
    \item Độ phức tạp thời gian
    \begin{itemize}[label=$\circ$]
        \item Trường hợp tốt nhất: $O\left(n^2\right)$.
        \item Trường hợp xấu nhất: $O\left(n^2\right)$.
        \item Trung bình: $O\left(n^2\right)$ vì thuật toán sử dụng 
        hai vòng lặp lồng nhau để tìm phần tử nhỏ nhất.
    \end{itemize}
    \item Độ phức tạp không gian: $O\left(1\right)$ vì không sử dụng 
    bộ nhớ bổ sung ngoài danh sách ban đầu.
\end{itemize}